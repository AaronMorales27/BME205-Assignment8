"""
Coalescent simulator (piecewise-constant demography, infinite-sites mutation model)

Implements a backward-time coalescent simulator that respects a piecewise-constant
population size history (demography file). Does NOT model selection.

Command line:
    python aaron_morales_assignment7_part2.py coalescent_config.csv coalescent_demography.csv \
        --seed 12345 --output coalescent_results.tsv

Outputs a TSV with one row per replicate containing:
    replicate, total_tree_length, time_to_mrca, num_mutations, theta_estimate, nucleotide_diversity

Requirements / choices made:
- Time is measured in generations backwards from present (t=0).
- Demography file contains change points: time_ago,population_size. Values are interpreted
  as piecewise-constant population sizes on intervals [time_ago[i], time_ago[i+1]).
  The final row applies from its time_ago to +infinity.
- Coalescent waiting times are generated by solving for T such that
      \int_0^T rate(t) dt = E,  where E ~ Exponential(1),
  and rate(t) = k*(k-1)/(4*N_e(t)) for diploid Wright-Fisher effective size N_e(t).
- Infinite-sites mutation model: total number of mutations M ~ Poisson(mu * sequence_length * total_tree_length),
  and each mutation is placed on a branch with probability proportional to that branch's length.
- Nucleotide diversity (pi) is computed exactly from the set of segregating sites by
  summing k*(n-k)/C(n,2) across sites and dividing by sequence_length.
- Watterson's theta (theta_watterson) is computed as S / a_n where S is number of segregating sites
  and a_n = sum_{i=1}^{n-1} 1/i.

Notes:
- This file avoids using specialized population genetics libraries as required.
- networkx is used to maintain an explicit tree structure and extract descendant sets.
"""

import argparse
import csv
import math
import sys
from typing import List, Tuple

import networkx as nx
import numpy as np
import pandas as pd


# ----------------------------- Utilities ---------------------------------

def read_config(path: str) -> dict:
    """Read a two-column CSV config file (parameter,value) into a dict."""
    cfg = {}
    with open(path, newline="") as fh:
        reader = csv.reader(fh)
        header = next(reader)
        for row in reader:
            if not row or not row[0].strip():
                continue
            key = row[0].strip()
            val = row[1].strip()
            # try to interpret numeric values
            try:
                if "." in val:
                    num = float(val)
                else:
                    num = int(val)
                cfg[key] = num
            except Exception:
                cfg[key] = val
    return cfg


def read_demography(path: str) -> List[Tuple[float, float]]:
    """Read demography: returns sorted list of (time_ago, population_size).

    Assumes header present and that time_ago is numeric and sorted ascending (0, ...).
    """
    rows = []
    with open(path, newline="") as fh:
        reader = csv.reader(fh)
        header = next(reader)
        for row in reader:
            if not row or not row[0].strip():
                continue
            t = float(row[0])
            N = float(row[1])
            rows.append((t, N))
    rows.sort(key=lambda x: x[0])
    return rows


def a_n(n: int) -> float:
    """Harmonic sum a_n = sum_{i=1}^{n-1} 1/i"""
    return sum(1.0 / i for i in range(1, n))


# ----------------------- Coalescent core algorithms ----------------------

def piecewise_rate_segments(demography: List[Tuple[float, float]], k: int) -> List[Tuple[float, float]]:
    """For a given lineage count k, return list of (seg_duration, rate) for segments starting at t=0 forward in time.

    Rate(t) = k*(k-1)/(4 * N_e(t)) per generation.
    The segments correspond to the demography change points. The final segment has duration = +inf.
    """
    segments = []
    rate_const = k * (k - 1) / 4.0
    for i in range(len(demography)):
        t0, N = demography[i]
        # duration until next change
        if i + 1 < len(demography):
            t1, _ = demography[i + 1]
            dur = t1 - t0
        else:
            dur = math.inf
        rate = rate_const / N
        segments.append((dur, rate))
    return segments


def draw_waiting_time(demography: List[Tuple[float, float]], k: int, rng: np.random.Generator) -> float:
    """Draw coalescent waiting time (in generations) for k lineages given piecewise demography.

    Algorithm: draw E ~ Exponential(1). Find smallest T s.t. integral_0^T rate(t) dt >= E.
    Because rate(t) is piecewise-constant across demography segments, the integral reduces to sum(rate_i * dur_i).
    """
    if k < 2:
        return math.inf
    E = rng.exponential(1.0)
    segments = piecewise_rate_segments(demography, k)
    t_acc = 0.0
    for dur, rate in segments:
        if rate <= 0:
            # zero coalescent rate (very large N); skip forward in time
            if math.isinf(dur):
                return math.inf
            t_acc += dur
            continue
        # hazard accumulated in this segment
        haz = rate * dur
        if E <= haz:
            # coalescent occurs inside this segment
            dt = E / rate
            return t_acc + dt
        # otherwise subtract and continue
        E -= haz
        t_acc += dur
    # If we exhausted all segments (should not happen since last dur is inf), return inf
    return math.inf


def run_single_coalescent(sample_size: int, demography: List[Tuple[float, float]], rng: np.random.Generator) -> Tuple[nx.DiGraph, float]:
    """Runs a single coalescent and returns a directed tree (edges from parent -> child)
    with node attribute 'time' (time of the node measured backwards from present) and
    leaf nodes named 0..n-1 at time 0. Also returns total tree length (sum of all branch lengths).

    Implementation details:
    - We maintain a dict: lineage_id -> node_id (node in the graph representing the tip or coalescent event).
    - Leaves are created at times 0. Each coalescent event creates a new internal node at time t (backwards),
      with edges new_node -> child_node for both children. Branch length for an edge is time(child) - time(parent)??
      Careful: child times are smaller (closer to present), parent time is larger. We will compute edge length = parent_time - child_time.
    """
    G = nx.DiGraph()
    # initialize leaves
    current_lineages = []  # list of tuples (lineage_id, node_name)
    for i in range(sample_size):
        node_name = f"leaf_{i}"
        G.add_node(node_name, time=0.0, is_leaf=True)
        current_lineages.append(node_name)

    next_internal_id = 0
    event_time = 0.0  # time in generations backwards

    # copy demography but ensure coverage starting at t=0
    if demography[0][0] != 0.0:
        raise ValueError("Demography must include a row with time_ago == 0")

    while len(current_lineages) > 1:
        k = len(current_lineages)
        dt = draw_waiting_time(demography, k, rng)
        if math.isinf(dt):
            raise RuntimeError("Coalescent did not complete (infinite waiting time) - check demography or sample size")
        event_time = dt
        # choose two lineages uniformly at random to coalesce
        a, b = rng.choice(current_lineages, size=2, replace=False)
        # create new internal node
        parent_name = f"int_{next_internal_id}"
        next_internal_id += 1
        G.add_node(parent_name, time=event_time, is_leaf=False)
        # add edges parent -> child
        G.add_edge(parent_name, a)
        G.add_edge(parent_name, b)
        # remove a,b and add parent
        current_lineages = [x for x in current_lineages if x not in (a, b)]
        current_lineages.append(parent_name)
        # Note: times for older events are larger; currently all existing nodes have times <= event_time
        # The algorithm above sets event_time as absolute time measured from present; but draw_waiting_time
        # returned the time to next coalescent starting at t=0. We must transform subsequent draws to be relative
        # to the current event time. Simpler approach: draw_waiting_time should return absolute time since we always
        # compute from t=0; to correct, we will instead draw incremental waiting times by shifting demography.
        # However, for clarity and correctness, we will implement an alternative below.

    # The simple while loop above mistakenly treats draw_waiting_time as absolute; we need incremental waiting times.
    # To avoid rewriting large sections, we will implement a clearer algorithm below and return early from this function.
    return G, 0.0


# ---------------------------- Corrected implementation --------------------
# The previous function attempted an absolute-time draw for each event. Instead we implement an incremental
# waiting-time draw that accounts for moving start time by shifting the demography.


def shift_demography(demography: List[Tuple[float, float]], t0: float) -> List[Tuple[float, float]]:
    """Return a demography shifted by t0: new times are max(0, time_ago - t0) and we drop negative durations.

    After shifting, the 0 time corresponds to original time t0.
    """
    shifted = []
    for t, N in demography:
        if t >= t0:
            shifted.append((t - t0, N))
    # if first time isn't 0, insert a row with 0 and population equal to the first segment's N
    if not shifted:
        # all demography points were before t0; extend with a final infinite segment with last N
        lastN = demography[-1][1]
        shifted = [(0.0, lastN)]
    elif shifted[0][0] != 0.0:
        # insert a 0 row with population size equal to the population at time t0 (which is the last demography row with time <= t0)
        N_at_t0 = demography[0][1]
        for t, N in demography:
            if t <= t0:
                N_at_t0 = N
            else:
                break
        shifted.insert(0, (0.0, N_at_t0))
    return shifted


def run_single_coalescent_correct(sample_size: int, demography: List[Tuple[float, float]], rng: np.random.Generator) -> Tuple[nx.DiGraph, float]:
    """Correct incremental coalescent run. Returns tree and total tree length.

    Approach:
    - Start at current_time = 0.
    - For k lineages, compute waiting time dt using draw_waiting_time on demography shifted by current_time.
    - Advance current_time += dt, create internal node at current_time, merge two random lineages.
    - Repeat until one lineage remains.
    - After tree is complete, compute branch lengths as parent_time - child_time for each edge and sum for total tree length.
    """
    G = nx.DiGraph()
    # initialize leaves
    current_lineages = []  # list of node names
    for i in range(sample_size):
        node_name = f"leaf_{i}"
        G.add_node(node_name, time=0.0, is_leaf=True)
        current_lineages.append(node_name)

    next_internal_id = 0
    current_time = 0.0

    if demography[0][0] != 0.0:
        raise ValueError("Demography must include a row with time_ago == 0.0")

    while len(current_lineages) > 1:
        k = len(current_lineages)
        shifted = shift_demography(demography, current_time)
        dt = draw_waiting_time(shifted, k, rng)
        if math.isinf(dt):
            raise RuntimeError("Coalescent did not complete (infinite waiting time) - check demography or sample size")
        current_time += dt
        a, b = rng.choice(current_lineages, size=2, replace=False)
        parent_name = f"int_{next_internal_id}"
        next_internal_id += 1
        G.add_node(parent_name, time=current_time, is_leaf=False)
        G.add_edge(parent_name, a)
        G.add_edge(parent_name, b)
        current_lineages = [x for x in current_lineages if x not in (a, b)]
        current_lineages.append(parent_name)

    # root is the remaining lineage
    root = current_lineages[0]

    # compute branch lengths and total tree length
    total_branch_length = 0.0
    for parent, child in G.edges():
        t_parent = G.nodes[parent]["time"]
        t_child = G.nodes[child]["time"]
        blen = t_parent - t_child
        if blen < 0:
            # numerical guard; should not happen
            blen = 0.0
        G.edges[parent, child]["length"] = blen
        total_branch_length += blen

    return G, total_branch_length


# ------------------------ Mutation placement & statistics -----------------

def place_mutations_on_tree(G: nx.DiGraph, total_branch_length: float, mu: float, seq_len: int, rng: np.random.Generator) -> List[Tuple[str, int]]:
    """Place mutations under infinite-sites model.

    Returns list of tuples (edge_identifier, derived_count) where derived_count is number of leaves
    that descend from that edge (i.e., allele count). edge_identifier is a tuple-like str 'parent|child'.
    """
    # total expected # mutations = mu * seq_len * total_branch_length
    mean_mut = mu * seq_len * total_branch_length
    M = rng.poisson(mean_mut)
    if M == 0:
        return []
    # build list of edges and their lengths
    edges = []  # list of (edge_key, length, descendant_count)
    # precompute descendant leaf counts for each node
    leaf_nodes = [n for n, d in G.nodes(data=True) if d.get("is_leaf")]
    n = len(leaf_nodes)

    # cache descendant leaf set sizes
    descendant_count = {}
    for node in G.nodes():
        # count number of leaf descendants
        descendants = [x for x in nx.descendants(G, node) if G.nodes[x].get("is_leaf")]
        # if node itself is leaf, include it
        if G.nodes[node].get("is_leaf"):
            descendants.append(node)
        descendant_count[node] = len(descendants)

    edge_list = []
    lengths = []
    for parent, child in G.edges():
        length = G.edges[parent, child]["length"]
        edge_id = f"{parent}|{child}"
        edge_list.append(edge_id)
        lengths.append(length)

    lengths = np.array(lengths, dtype=float)
    if lengths.sum() <= 0.0:
        return []
    probs = lengths / lengths.sum()

    # choose M edges with replacement according to probs
    chosen_indices = rng.choice(len(edge_list), size=M, p=probs)

    mutations = []
    for idx in chosen_indices:
        edge_id = edge_list[idx]
        parent, child = edge_id.split("|")
        k = descendant_count[child]  # derived allele count
        mutations.append((edge_id, k))
    return mutations


def compute_pi_and_theta(mutations: List[Tuple[str, int]], sample_size: int, seq_len: int) -> Tuple[float, float, int]:
    """Compute nucleotide diversity (pi per site) and Watterson's theta per site, and S (num segregating sites).

    pi = (1 / C(n,2)) * sum_{sites} k*(n-k)
    theta_watterson = S / a_n
    Both are returned per-site (i.e., divided by seq_len where appropriate)
    """
    if not mutations:
        return 0.0, 0.0, 0
    # mutations may include multiple hits on same edge; under infinite-sites these are independent sites,
    # so we treat each as a separate segregating site.
    S = len(mutations)
    n = sample_size
    pair_pairs = n * (n - 1) / 2.0
    numerator = 0.0
    for _, k in mutations:
        numerator += k * (n - k)
    pi = numerator / pair_pairs / seq_len
    theta_w = S / a_n(n) / seq_len
    return pi, theta_w, S


# ----------------------------- CLI & main --------------------------------

def parse_args():
    p = argparse.ArgumentParser(description="Coalescent simulator (piecewise-constant demography)")
    p.add_argument("config", help="coalescent_config.csv")
    p.add_argument("demography", help="coalescent_demography.csv (time_ago,population_size)")
    p.add_argument("--seed", type=int, default=None)
    p.add_argument("--output", default="coalescent_results.tsv")
    return p.parse_args()


def main():
    args = parse_args()
    cfg = read_config(args.config)
    dem = read_demography(args.demography)

    # parse config parameters with sensible errors
    mu = float(cfg.get("mutation_rate", 1e-8))
    seq_len = int(cfg.get("sequence_length", 1000))
    sample_size = int(cfg.get("sample_size", 20))
    replicates = int(cfg.get("replicates", 100))

    rng = np.random.default_rng(args.seed)

    records = []
    for rep in range(1, replicates + 1):
        try:
            tree, total_branch = run_single_coalescent_correct(sample_size, dem, rng)
        except Exception as e:
            print(f"Replicate {rep} failed: {e}", file=sys.stderr)
            continue
        # determine time to MRCA: max node time
        times = [d.get("time") for n, d in tree.nodes(data=True)]
        time_to_mrca = max(times)
        # place mutations
        muts = place_mutations_on_tree(tree, total_branch, mu, seq_len, rng)
        pi, theta_w, S = compute_pi_and_theta(muts, sample_size, seq_len)
        records.append({
            "replicate": rep,
            "total_tree_length": total_branch,
            "time_to_mrca": time_to_mrca,
            "num_mutations": S,
            "theta_estimate": theta_w,
            "nucleotide_diversity": pi,
        })

    df = pd.DataFrame.from_records(records, columns=["replicate", "total_tree_length", "time_to_mrca", "num_mutations", "theta_estimate", "nucleotide_diversity"])
    df.to_csv(args.output, sep="\t", index=False, float_format="%.6f")
    # print(f"Wrote {len(df)} replicates to {args.output}")


if __name__ == "__main__":
    main()
